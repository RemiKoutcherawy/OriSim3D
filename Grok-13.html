<!DOCTYPE html>
<style>canvas { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }</style>
<canvas id="c"></canvas>
<script>
  const c = document.getElementById("c"), ctx = c.getContext("2d");
  let width, height, imgData, depthBuffer;

  // Load textures
  const frontImg = new Image(), backImg = new Image();
  frontImg.src = 'textures/front.jpg';
  backImg.src = 'textures/back.jpg';
  let frontData, backData, texWidth, texHeight, texturesLoaded = 0;

  function loadTexture(img, callback) {
    img.onload = () => {
      const texCanvas = document.createElement("canvas");
      texCanvas.width = texWidth = img.width;
      texCanvas.height = texHeight = img.height;
      const texCtx = texCanvas.getContext("2d");
      // Invert the image in y-direction
      texCtx.scale(1, -1);
      texCtx.translate(0, -texHeight);
      texCtx.drawImage(img, 0, 0);
      callback(texCtx.getImageData(0, 0, texWidth, texHeight).data);
      if (++texturesLoaded === 2) render();
    };
  }
  loadTexture(frontImg, data => frontData = data);
  loadTexture(backImg, data => backData = data);

  function resize() {
    width = c.width = window.innerWidth;
    height = c.height = window.innerHeight;
    imgData = ctx.createImageData(width, height);
    depthBuffer = Array(height).fill().map(() => Array(width).fill(Infinity));
  }
  window.onresize = resize;
  resize();

  function putPixel(x, y, color, z) {
    x = Math.floor(x); y = Math.floor(y);
    if (x < 0 || x >= width || y < 0 || y >= height) return;
      if (z < depthBuffer[y][x]) {
      const i = (y * width + x) * 4;
      imgData.data[i] = color[0]; imgData.data[i + 1] = color[1]; imgData.data[i + 2] = color[2]; imgData.data[i + 3] = 255;
      depthBuffer[y][x] = z;
    }
  }

  function cross(v1, v2) {
    return [v1[1]*v2[2]-v1[2]*v2[1], v1[2]*v2[0]-v1[0]*v2[2], v1[0]*v2[1]-v1[1]*v2[0]];
  }

  function dot(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
  }

  function normalize(v) {
    const len = Math.sqrt(dot(v, v));
    return len ? [v[0]/len, v[1]/len, v[2]/len] : v;
  }

  function createMat4() {
    return [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]];
  }

  function multiplyMat4(a, b) {
    const r = createMat4();
    for (let i = 0; i < 4; i++)
      for (let j = 0; j < 4; j++)
        r[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j] + a[i][3]*b[3][j];
    return r;
  }

  function transformVec4(mat, vec) {
    const r = [0, 0, 0, 0];
    for (let i = 0; i < 4; i++)
      r[i] = mat[i][0]*vec[0] + mat[i][1]*vec[1] + mat[i][2]*vec[2] + mat[i][3]*vec[3];
    return r;
  }

  function perspectiveMat4(fov, aspect, near, far) {
    const f = 1/Math.tan(fov/2), nf = 1/(near-far);
    return [[f/aspect,0,0,0], [0,f,0,0], [0,0,(far+near)*nf,2*far*near*nf], [0,0,-1,0]];
  }

  function translateMat4(tx, ty, tz) {
    return [[1,0,0,tx], [0,1,0,ty], [0,0,1,tz], [0,0,0,1]];
  }

  function rotateYMat4(angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return [[c,0,s,0], [0,1,0,0], [-s,0,c,0], [0,0,0,1]];
  }

  function inverseTransposeMat4(mat) {
    const r = createMat4();
    const c = mat[0][0], s = mat[2][0]; // For rotation Y matrix
    r[0][0] = c; r[0][2] = -s;
    r[1][1] = 1;
    r[2][0] = s; r[2][2] = c;
    return r;
  }

  function transformNormal(mat, normal) {
    const r = [0, 0, 0];
    for (let i = 0; i < 3; i++)
      r[i] = mat[i][0]*normal[0] + mat[i][1]*normal[1] + mat[i][2]*normal[2];
    return normalize(r);
  }

  const vertices = [
    [-100,-100,0,1], [100,-100,0,1], [100,100,0,1], [-100,100,0,1]
  ];

  const uvs = [
    [0,0], [1,0], [1,1], [0,1]
  ];

  const triangles = [
    {v: [0,1,2], uv: [0,1,2]},
    {v: [0,2,3], uv: [0,2,3]}
  ];

  function fillTriangle(p0, p1, p2, z0, z1, z2, uv0, uv1, uv2, w0, w1, w2, tex, factor) {
    const minX = Math.max(0, Math.floor(Math.min(p0[0], p1[0], p2[0])));
    const maxX = Math.min(width-1, Math.ceil(Math.max(p0[0], p1[0], p2[0])));
    const minY = Math.max(0, Math.floor(Math.min(p0[1], p1[1], p2[1])));
    const maxY = Math.min(height-1, Math.ceil(Math.max(p0[1], p1[1], p2[1])));
      for (let y = minY; y <= maxY; y++) {
      for (let x = minX; x <= maxX; x++) {
        const b0 = ((p1[1]-p2[1])*(x-p2[0]) + (p2[0]-p1[0])*(y-p2[1])) /
                ((p1[1]-p2[1])*(p0[0]-p2[0]) + (p2[0]-p1[0])*(p0[1]-p2[1]));
        const b1 = ((p2[1]-p0[1])*(x-p2[0]) + (p0[0]-p2[0])*(y-p2[1])) /
                ((p2[1]-p0[1])*(p1[0]-p2[0]) + (p0[0]-p2[0])*(p1[1]-p2[1]));
        const b2 = 1 - b0 - b1;
        if (b0 >= 0 && b1 >= 0 && b2 >= 0) {
          const z = b0 * z0 + b1 * z1 + b2 * z2;
          const invW = b0/w0 + b1/w1 + b2/w2;
          const u = (b0*uv0[0]/w0 + b1*uv1[0]/w1 + b2*uv2[0]/w2) / invW;
          const v = (b0*uv0[1]/w0 + b1*uv1[1]/w1 + b2*uv2[1]/w2) / invW;
          const tx = Math.floor(u * texWidth) % texWidth;
          const ty = Math.floor(v * texHeight) % texHeight;
          const ti = (ty * texWidth + tx) * 4;
          const color = [tex[ti] * factor, tex[ti + 1] * factor, tex[ti + 2] * factor]
                  .map(c => Math.min(255, Math.max(0, Math.floor(c))));
          putPixel(x, y, color, z);
        }
      }
    }
  }

  const lightDir = normalize([0, 0, -1]);
  const ambient = 0.2;
  let angle = 0;
  function renderTriangles(invTransModel, projected) {
      triangles.forEach(t => {
          const v0 = vertices[t.v[0]], v1 = vertices[t.v[1]], v2 = vertices[t.v[2]];
          const e1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
          const e2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];
          let normal = normalize(cross(e1, e2));
          normal = transformNormal(invTransModel, normal);
          const isFront = dot(normal, [0, 0, -1]) > 0; // Camera looks along -Z
          const tex = isFront ? frontData : backData;
          const lightNormal = isFront ? normal : [-normal[0], -normal[1], -normal[2]]; // Flip normal for back face
          const factor = Math.max(0, dot(lightNormal, lightDir)) * (1 - ambient) + ambient;
          const uv0 = uvs[t.uv[0]], uv1 = uvs[t.uv[1]], uv2 = uvs[t.uv[2]];
          const p0 = projected[t.v[0]], p1 = projected[t.v[1]], p2 = projected[t.v[2]];
          const z0 = p0[2], z1 = p1[2], z2 = p2[2];
          const w0 = p0[3], w1 = p1[3], w2 = p2[3];
          fillTriangle(p0, p1, p2, z0, z1, z2, uv0, uv1, uv2, w0, w1, w2, tex, factor);
      });
  }

  function render() {
    if (texturesLoaded < 2) return;
    angle += 0.01;
    for (let i = 0; i < imgData.data.length; i += 4) imgData.data[i + 3] = 0;
    for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) depthBuffer[y][x] = Infinity;
    const proj = perspectiveMat4(Math.PI/3, width/height, 0.1, 100);
    const view = translateMat4(0, 0, -500);
    const model = rotateYMat4(angle);
    let mvp = multiplyMat4(proj, view);
    mvp = multiplyMat4(mvp, model);
    const invTransModel = inverseTransposeMat4(model);
    const projected = vertices.map(v => {
      const tv = transformVec4(mvp, v);
      const w = tv[3];
        return [(tv[0]/w + 1) * width/2, (1 - tv[1]/w) * height/2, tv[2]/w, w];
    });
    renderTriangles(invTransModel, projected);
    ctx.putImageData(imgData, 0, 0);
    requestAnimationFrame(render);
  }
</script>
