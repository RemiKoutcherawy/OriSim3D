<!DOCTYPE html>
<style>canvas { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }</style>
<canvas id="c"></canvas>
<script>
    const c = document.getElementById("c"), ctx = c.getContext("2d");
    let width, height, imgData, depthBuffer;

    // Load textures
    const frontImg = new Image(), backImg = new Image();
    frontImg.src = 'textures/front.jpg';
    backImg.src = 'textures/back.jpg';
    let frontData, backData, texWidth, texHeight, texturesLoaded = 0;

    function loadTexture(img, callback) {
        img.onload = () => {
            const texCanvas = document.createElement("canvas");
            texCanvas.width = texWidth = img.width;
            texCanvas.height = texHeight = img.height;
            const texCtx = texCanvas.getContext("2d");
            texCtx.drawImage(img, 0, 0);
            callback(texCtx.getImageData(0, 0, texWidth, texHeight).data);
            if (++texturesLoaded === 2) render(); // Start rendering after both textures are loaded
        };
    }
    loadTexture(frontImg, data => frontData = data);
    loadTexture(backImg, data => backData = data);

    function resize() {
        width = c.width = window.innerWidth;
        height = c.height = window.innerHeight;
        imgData = ctx.createImageData(width, height);
        depthBuffer = Array(height).fill(undefined).map(() => Array(width).fill(Infinity));
    }
    window.onresize = resize;
    resize();

    function putPixel(x, y, color, z) {
        x = Math.floor(x); y = Math.floor(y);
        if (x < 0 || x >= width || y < 0 || y >= height) return;
        if (z < depthBuffer[y][x]) {
            const i = (y * width + x) * 4;
            imgData.data[i] = color[0]; imgData.data[i + 1] = color[1]; imgData.data[i + 2] = color[2]; imgData.data[i + 3] = 255;
            depthBuffer[y][x] = z;
        }
    }

    function cross(v1, v2) {
        return [v1[1]*v2[2]-v1[2]*v2[1], v1[2]*v2[0]-v1[0]*v2[2], v1[0]*v2[1]-v1[1]*v2[0]];
    }

    function dot(v1, v2) {
        return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
    }

    function normalize(v) {
        const len = Math.sqrt(dot(v, v));
        return len ? [v[0]/len, v[1]/len, v[2]/len] : v;
    }

    function createMat4() {
        return [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]];
    }

    function multiplyMat4(a, b) {
        const r = createMat4();
        for (let i = 0; i < 4; i++)
            for (let j = 0; j < 4; j++)
                r[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j] + a[i][3]*b[3][j];
        return r;
    }

    function transformVec4(mat, vec) {
        const r = [0, 0, 0, 0];
        for (let i = 0; i < 4; i++)
            r[i] = mat[i][0]*vec[0] + mat[i][1]*vec[1] + mat[i][2]*vec[2] + mat[i][3]*vec[3];
        return r;
    }

    function perspectiveMat4(fov, aspect, near, far) {
        const f = 1/Math.tan(fov/2), nf = 1/(near-far);
        return [[f/aspect,0,0,0], [0,f,0,0], [0,0,(far+near)*nf,2*far*near*nf], [0,0,-1,0]];
    }

    function translateMat4(tx, ty, tz) {
        return [[1,0,0,tx], [0,1,0,ty], [0,0,1,tz], [0,0,0,1]];
    }

    function rotateYMat4(angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        return [[c,0,s,0], [0,1,0,0], [-s,0,c,0], [0,0,0,1]];
    }

    const vertices = [
        [-100,-100,0,1], [100,-100,0,1], [100,100,0,1], [-100,100,0,1]
    ];

    const uvs = [
        [0,0], [1,0], [1,1], [0,1]
    ];

    const triangles = [
        {v: [0,1,2], uv: [0,1,2]},
        {v: [0,2,3], uv: [0,2,3]}
    ];

    function fillTriangle(p0, p1, p2, z0, z1, z2, uv0, uv1, uv2, isFront) {
        const minX = Math.max(0, Math.floor(Math.min(p0[0], p1[0], p2[0])));
        const maxX = Math.min(width-1, Math.ceil(Math.max(p0[0], p1[0], p2[0])));
        const minY = Math.max(0, Math.floor(Math.min(p0[1], p1[1], p2[1])));
        const maxY = Math.min(height-1, Math.ceil(Math.max(p0[1], p1[1], p2[1])));

        const tex = isFront ? frontData : backData;
        for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
                const w0 = ((p1[1]-p2[1])*(x-p2[0]) + (p2[0]-p1[0])*(y-p2[1])) /
                    ((p1[1]-p2[1])*(p0[0]-p2[0]) + (p2[0]-p1[0])*(p0[1]-p2[1]));
                const w1 = ((p2[1]-p0[1])*(x-p2[0]) + (p0[0]-p2[0])*(y-p2[1])) /
                    ((p2[1]-p0[1])*(p1[0]-p2[0]) + (p0[0]-p2[0])*(p1[1]-p2[1]));
                const w2 = 1 - w0 - w1;
                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
                    const z = w0 * z0 + w1 * z1 + w2 * z2;
                    const u = w0 * uv0[0] + w1 * uv1[0] + w2 * uv2[0];
                    const v = w0 * uv0[1] + w1 * uv1[1] + w2 * uv2[1];
                    const tx = Math.floor(u * texWidth) % texWidth;
                    const ty = Math.floor(v * texHeight) % texHeight;
                    const ti = (ty * texWidth + tx) * 4;
                    const color = [tex[ti], tex[ti + 1], tex[ti + 2]];
                    putPixel(x, y, color, z);
                }
            }
        }
    }

    let angle = 0;
    function render() {
        if (texturesLoaded < 2) return;
        angle += 0.01;
        for (let i = 0; i < imgData.data.length; i += 4) imgData.data[i + 3] = 0;
        for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) depthBuffer[y][x] = Infinity;

        const proj = perspectiveMat4(Math.PI/3, width/height, 0.1, 100);
        const view = translateMat4(0, 0, -500);
        const model = rotateYMat4(angle);
        let mvp = multiplyMat4(proj, view);
        mvp = multiplyMat4(mvp, model);

        const projected = vertices.map(v => {
            const tv = transformVec4(mvp, v);
            const w = tv[3];
            return [(tv[0]/w + 1) * width/2, (1 - tv[1]/w) * height/2, tv[2]/w];
        });

        triangles.forEach(t => {
            const v0 = vertices[t.v[0]], v1 = vertices[t.v[1]], v2 = vertices[t.v[2]];
            const e1 = [v1[0]-v0[0], v1[1]-v0[1], v1[2]-v0[2]];
            const e2 = [v2[0]-v0[0], v2[1]-v0[1], v2[2]-v0[2]];
            let normal = normalize(cross(e1, e2));
            const isFront = dot(normal, [0, 0, 1]) > 0;
            const uv0 = uvs[t.uv[0]], uv1 = uvs[t.uv[1]], uv2 = uvs[t.uv[2]];
            const p0 = projected[t.v[0]], p1 = projected[t.v[1]], p2 = projected[t.v[2]];
            const z0 = projected[t.v[0]][2], z1 = projected[t.v[1]][2], z2 = projected[t.v[2]][2];
            fillTriangle(p0, p1, p2, z0, z1, z2, uv0, uv1, uv2, isFront);
        });

        ctx.putImageData(imgData, 0, 0);
        requestAnimationFrame(render);
    }
</script>
