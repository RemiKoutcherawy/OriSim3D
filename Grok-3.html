<!DOCTYPE html>
<canvas id="c" width="400" height="400" style="background: black"></canvas>
<script>
    // Canvas 2D setup
    const ctx = c.getContext("2d");
    const imgData = ctx.createImageData(400, 400);

    // Put pixel function
    function putPixel(x, y, color) {
        if (x < 0 || x >= 400 || y < 0 || y >= 400) return;
        const i = (Math.floor(y) * 400 + Math.floor(x)) * 4;
        imgData.data[i] = color[0]; imgData.data[i + 1] = color[1]; imgData.data[i + 2] = color[2]; imgData.data[i + 3] = 255;
    }

    // Matrix 4x4 functions
    function createMat4() {
        return [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]];
    }

    function multiplyMat4(a, b) {
        const r = createMat4();
        for (let i = 0; i < 4; i++)
            for (let j = 0; j < 4; j++)
                r[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j] + a[i][3]*b[3][j];
        return r;
    }

    function transformVec4(mat, vec) {
        const r = [0, 0, 0, 0];
        for (let i = 0; i < 4; i++)
            r[i] = mat[i][0]*vec[0] + mat[i][1]*vec[1] + mat[i][2]*vec[2] + mat[i][3]*vec[3];
        return r;
    }

    function perspectiveMat4(fov, aspect, near, far) {
        const f = 1/Math.tan(fov/2), nf = 1/(near-far);
        return [[f/aspect,0,0,0], [0,f,0,0], [0,0,(far+near)*nf,2*far*near*nf], [0,0,-1,0]];
    }

    function translateMat4(tx, ty, tz) {
        return [[1,0,0,tx], [0,1,0,ty], [0,0,1,tz], [0,0,0,1]];
    }

    function rotateYMat4(angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        return [[c,0,s,0], [0,1,0,0], [-s,0,c,0], [0,0,0,1]];
    }

    // Cube vertices
    const vertices = [
        [-1,-1,-1,1], [1,-1,-1,1], [1,1,-1,1], [-1,1,-1,1], // Front
        [-1,-1,1,1],  [1,-1,1,1],  [1,1,1,1],  [-1,1,1,1]   // Back
    ];

    // Cube triangles (2 per face, 6 faces, with colors)
    const triangles = [
        // Front (red)
        {v: [0,1,2], c: [255,0,0]}, {v: [0,2,3], c: [255,0,0]},
        // Back (green)
        {v: [5,4,7], c: [0,255,0]}, {v: [5,7,6], c: [0,255,0]},
        // Left (blue)
        {v: [4,0,3], c: [0,0,255]}, {v: [4,3,7], c: [0,0,255]},
        // Right (yellow)
        {v: [1,5,6], c: [255,255,0]}, {v: [1,6,2], c: [255,255,0]},
        // Top (cyan)
        {v: [3,2,6], c: [0,255,255]}, {v: [3,6,7], c: [0,255,255]},
        // Bottom (magenta)
        {v: [4,5,1], c: [255,0,255]}, {v: [4,1,0], c: [255,0,255]}
    ];

    // Fill triangle (simple bounding box scan)
    function fillTriangle(p0, p1, p2, color) {
        const minX = Math.max(0, Math.floor(Math.min(p0[0], p1[0], p2[0])));
        const maxX = Math.min(399, Math.ceil(Math.max(p0[0], p1[0], p2[0])));
        const minY = Math.max(0, Math.floor(Math.min(p0[1], p1[1], p2[1])));
        const maxY = Math.min(399, Math.ceil(Math.max(p0[1], p1[1], p2[1])));

        for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
                // Barycentric coordinates (simplified)
                const w0 = ((p1[1]-p2[1])*(x-p2[0]) + (p2[0]-p1[0])*(y-p2[1])) /
                    ((p1[1]-p2[1])*(p0[0]-p2[0]) + (p2[0]-p1[0])*(p0[1]-p2[1]));
                const w1 = ((p2[1]-p0[1])*(x-p2[0]) + (p0[0]-p2[0])*(y-p2[1])) /
                    ((p2[1]-p0[1])*(p1[0]-p2[0]) + (p0[0]-p2[0])*(p1[1]-p2[1]));
                const w2 = 1 - w0 - w1;
                if (w0 >= 0 && w1 >= 0 && w2 >= 0) putPixel(x, y, color);
            }
        }
    }

    // Animation
    let angle = 0;
    function render() {
        angle += 0.01;
        // Clear canvas
        for (let i = 0; i < imgData.data.length; i += 4) imgData.data[i + 3] = 0;

        // Transformations
        const proj = perspectiveMat4(Math.PI/3, 1, 0.1, 100);
        const view = translateMat4(0, 0, -5);
        const model = rotateYMat4(angle);
        let mvp = multiplyMat4(proj, view);
        mvp = multiplyMat4(mvp, model);

        // Project vertices
        const projected = vertices.map(v => {
            const tv = transformVec4(mvp, v);
            const w = tv[3];
            return [(tv[0]/w + 1) * 200, (1 - tv[1]/w) * 200, tv[2]/w]; // [x, y, z]
        });

        // Sort triangles by depth (painter's algorithm)
        const sortedTriangles = triangles.map(t => {
            const zAvg = (projected[t.v[0]][2] + projected[t.v[1]][2] + projected[t.v[2]][2]) / 3;
            return {t, zAvg};
        }).sort((a, b) => b.zAvg - a.zAvg);

        // Draw triangles
        sortedTriangles.forEach(({t}) => {
            const p0 = projected[t.v[0]], p1 = projected[t.v[1]], p2 = projected[t.v[2]];
            fillTriangle(p0, p1, p2, t.c);
        });

        ctx.putImageData(imgData, 0, 0);
        requestAnimationFrame(render);
    }

    render();
</script>
