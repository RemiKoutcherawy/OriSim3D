<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Conception Three.js</title>
</head>
<body>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js"
        }
    }
</script>
<!-- Utilisation de three et OrbitControls via CDN -->
<script type="module">
    import * as three from 'three';
    import { OrbitControls } from './js/OrbitControls.js';
    import { Model } from './js/Model.js';
    import { Command } from './js/Command.js';

    // Scène
    const scene = new three.Scene();
    scene.background = new three.Color(0xCCE4FF);

    // Caméra
    const camera = new three.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 400);
    camera.lookAt(0, 0, 0);

    // Rendu
    const renderer = new three.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Lumières
    const ambient = new three.AmbientLight(0xffffff, 1);
    scene.add(ambient);
    // Lumière directionnelle principale venant de face
    const dir = new three.DirectionalLight(0xffffff, 2);
    dir.position.set(0, 0, 1);
    scene.add(dir);

    // Textures
    const frontTexture = new three.TextureLoader().load('textures/front.jpg');
    frontTexture.colorSpace = three.SRGBColorSpace;
    const backTexture = new three.TextureLoader().load('textures/back.jpg');
    backTexture.colorSpace = three.SRGBColorSpace;
    const TEX_W = 400, TEX_H = 400;

    // Origami
    const model = new Model().init();
    let geometry = createGeometry(model);
    const command = new Command(model, geometry);

    function createGeometry(model) {
        const geometry = new three.BufferGeometry();

        // Faces
        const vtx = []; // vertex
        const ftx = []; // front texture coords
        const fnr = []; // front normals coords
        const fin = []; // front indices
        let index = 0;

        for (let iFace = 0; iFace < model.faces.length; iFace++) {
            const f = model.faces[iFace];
            const pts = f.points;
            // Normal needed for Offset and used for lightning
            f.normal = faceNormal(pts);
            const n = f.normal;
            // Triangle FAN can be used only because of convex CCW face
            const c = pts[0]; // center
            let p = pts[1]; // previous
            let s; // current point
            for (let i = 2; i < pts.length; i++) {
                s = pts[i];
                vtx.push(c.x + f.offset * n[0]);
                vtx.push(c.y + f.offset * n[1]);
                vtx.push(c.z + f.offset * n[2]);
                fnr.push(n[0], n[1], n[2]);
                // textures
                ftx.push((200 + c.xf) / TEX_W);
                ftx.push((200 + c.yf) / TEX_H);
                // index
                fin.push(index++);

                vtx.push(p.x + f.offset * n[0]);
                vtx.push(p.y + f.offset * n[1]);
                vtx.push(p.z + f.offset * n[2]);
                fnr.push(n[0], n[1], n[2]);
                // textures
                ftx.push((200 + p.xf) / TEX_W);
                ftx.push((200 + p.yf) / TEX_H);
                // index
                fin.push(index++);

                vtx.push(s.x + f.offset * n[0]);
                vtx.push(s.y + f.offset * n[1]);
                vtx.push(s.z + f.offset * n[2]);
                fnr.push(n[0], n[1], n[2]);
                // textures
                ftx.push((200 + s.xf) / TEX_W);
                ftx.push((200 + s.yf) / TEX_H);
                // index
                fin.push(index++);
                // next triangle
                p = s;
            }

            function faceNormal(pts) {
                const n = [3];
                for (let i = 0; i < pts.length - 2; i++) {
                    // Take triangles until p2p1 x p1p3 > 0.1
                    const p1 = pts[i], p2 = pts[i + 1], p3 = pts[i + 2];
                    const u = [p2.x - p1.x, p2.y - p1.y, p2.z - p1.z];
                    const v = [p3.x - p1.x, p3.y - p1.y, p3.z - p1.z];
                    n[0] = u[1] * v[2] - u[2] * v[1];
                    n[1] = u[2] * v[0] - u[0] * v[2];
                    n[2] = u[0] * v[1] - u[1] * v[0];
                    if (Math.abs(n[0]) + Math.abs(n[1]) + Math.abs(n[2]) > 0.1) {
                        break;
                    }
                }
                return n;
            }
        }

        // Attributes
        geometry.setAttribute('position', new three.BufferAttribute(new Float32Array(vtx), 3));
        geometry.setAttribute('normal', new three.BufferAttribute(new Float32Array(fnr), 3));
        geometry.setAttribute('uv', new three.BufferAttribute(new Float32Array(ftx), 2));
        geometry.setIndex(fin);
        return geometry;
    }

    const frontMat = new three.MeshPhongMaterial({
        color: 0xFFFFFF,
        side: three.FrontSide,
        map: frontTexture,
        specular: 0x444444,
        shininess: 100,
    });
    const backMat = new three.MeshPhongMaterial({
        color: 0xFFFFFF,
        side: three.BackSide,
        map: backTexture,
        specular: 0x444444,
        shininess: 100,
    });
    const front = new three.Mesh(geometry, frontMat);
    const back = new three.Mesh(geometry, backMat);
    scene.add(front);
    scene.add(back);

    // Wireframe
    const wireMaterial = new three.MeshLambertMaterial({ color: 0x000000, wireframe: true });
    const wireMesh = new three.Mesh(geometry, wireMaterial);
    scene.add(wireMesh);

    // Controls
    // C'est la caméra et non la géométrie qui est modifiée
    // camera.updateProjectionMatrix()
    // voir view3d avec updateProjectionMatrix
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.update();
    orbit.saveState();
    orbit.addEventListener('change', animate);
    window.addEventListener('dblclick', () => { orbit.reset(); });

    // Update geometry when the model changed
    function updateGeometry() {
        const oldGeometry = geometry;
        geometry = createGeometry(model);
        front.geometry = geometry;
        back.geometry = geometry;
        wireMesh.geometry = geometry;
        geometry.computeBoundingSphere();
        geometry.computeBoundingBox();
        if (oldGeometry && oldGeometry !== geometry) {
            oldGeometry.dispose();
        }
        geometry.attributes.uv.needsUpdate = true;
        geometry.attributes.normal.needsUpdate = true;
        geometry.attributes.position.needsUpdate = true;
        geometry.index.needsUpdate = true;
    }

    // Boucle de rendu
    function animate() {
        requestAnimationFrame(animate);
        const changed = command.anim();
        if (changed) {
            updateGeometry();
        }
        renderer.render(scene, camera);
    }

    animate();

    // Ajuster au redimensionnement
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Origami script injection
    const script = document.getElementById('origami.txt');
    command.command(script.textContent);
</script>

<!-- Cocotte script -->
<div id="origami.txt" hidden="hidden">
    define 210 300
    lines
    // Fold top on bottom
    across2d 1 2;
    offset -1 0
    t 200 r 6 -180 2 3;
    t 200 fit;
    // Crease edges at 45°
    across3d 4 5
    bisector3d 7 9
    bisector3d 6 9

    // Fold corners
    offset -1 3 0
    t 200 rotate 13 -180 4
    t 200 rotate 17 180 5
</div>
</body>
</html>
