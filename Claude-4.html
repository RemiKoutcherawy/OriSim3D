<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Cocotte 3D</title>
    <style>body{margin:0;overflow:hidden;background:#111}</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let scene, camera, renderer, mesh, vertices, indices, time = 0;

    // Init buffers like view3d.initBuffers()
    function initBuffers() {
        const size = 2, segs = 8, step = size / segs;
        vertices = new Float32Array((segs + 1) * (segs + 1) * 3);
        indices = new Uint16Array(segs * segs * 6);

        // Create vertex grid
        let vIdx = 0;
        for (let i = 0; i <= segs; i++) {
            for (let j = 0; j <= segs; j++) {
                vertices[vIdx++] = (j - segs/2) * step;
                vertices[vIdx++] = (i - segs/2) * step;
                vertices[vIdx++] = 0;
            }
        }

        // Create triangles
        let iIdx = 0;
        for (let i = 0; i < segs; i++) {
            for (let j = 0; j < segs; j++) {
                const a = i * (segs + 1) + j;
                const b = a + 1;
                const c = a + segs + 1;
                const d = c + 1;

                indices[iIdx++] = a; indices[iIdx++] = b; indices[iIdx++] = c;
                indices[iIdx++] = b; indices[iIdx++] = d; indices[iIdx++] = c;
            }
        }
    }

    // Update geometry like Model.js folding
    function updateGeometry() {
        const fold = Math.sin(time * 0.6) * 0.7 + 0.3;
        const twist = Math.sin(time * 0.8) * 0.5;

        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i], y = vertices[i + 1];
            let z = 0;

            // Diagonal fold lines
            const diag1 = Math.abs(x - y);
            const diag2 = Math.abs(x + y);
            if (diag1 < 0.15) z += fold * 0.8;
            if (diag2 < 0.15) z -= fold * 0.6;

            // Corner lifting
            const r = Math.sqrt(x*x + y*y);
            if (r > 0.8) z += twist * Math.sign(x*y) * 0.5;

            vertices[i + 2] = z;
        }

        mesh.geometry.attributes.position.needsUpdate = true;
        mesh.geometry.computeVertexNormals();
    }

    // Setup
    initBuffers();

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 100);
    camera.position.z = 4;

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0x404040, 0.3));
    const light = new THREE.DirectionalLight(0xffffff, 0.7);
    light.position.set(3, 3, 3);
    scene.add(light);

    // Create mesh with BufferGeometry
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geo.setIndex(new THREE.BufferAttribute(indices, 1));
    geo.computeVertexNormals();

    mesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({
        color: 0xff4757,
        side: THREE.DoubleSide
    }));
    scene.add(mesh);

    // Animate
    function animate() {
        time += 0.016;
        updateGeometry();
        mesh.rotation.y = time * 0.2;
        mesh.rotation.x = Math.sin(time * 0.3) * 0.1;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    onresize = () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    };

    animate();
</script>
</body>
</html>
