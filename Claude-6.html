<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Cocotte Model.js + Three.js</title>
    <style>body{margin:0;overflow:hidden;background:#fff}</style>
</head>
<body>
<script type="module">
    import { Model } from './js/Model.js';
    import * as THREE from './js/three.module.js';

    // Extension of Model.js for Three.js rendering
    class OrigamiRenderer {
        // Generate BufferGeometry from Model data
        static createBufferGeometry(model) {
            const vertices = [];
            const indices = [];

            // Convert faces to triangles
            model.faces.forEach(face => {
                // Todo: use face.points
                const [a, b, c] = face.points;
                const startIdx = vertices.length / 3;

                // Add vertices
                vertices.push(a.x, a.y, a.z);
                vertices.push(b.x, b.y, b.z);
                vertices.push(c.x, c.y, c.z);

                // Add indices
                indices.push(startIdx, startIdx + 1, startIdx + 2);
            });

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            return geometry;
        }
    }

    // Scene setup
    let scene, camera, renderer, mesh, time = 0;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0x404040, 0.4));
    const light = new THREE.DirectionalLight(0xffffff, 0.6);
    light.position.set(100, 100, 50);
    scene.add(light);

    // Create origami using Model.js
    const model = new Model().init(100, 100);

    // Create mesh with initial geometry
    const material = new THREE.MeshLambertMaterial({
        color: 0xff6b6b,
        side: THREE.DoubleSide
    });

    mesh = new THREE.Mesh(OrigamiRenderer.createBufferGeometry(model), material);
    scene.add(mesh);

    // Animation loop
    function animate() {
        // Update BufferGeometry
        const newGeometry = OrigamiRenderer.createBufferGeometry(model);
        mesh.geometry.dispose();
        mesh.geometry = newGeometry;

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    onresize = () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    };

    animate();
</script>
</body>
</html>
