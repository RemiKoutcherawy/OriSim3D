<!DOCTYPE html>
<canvas id="c" width="400" height="400"></canvas>
<script type="module">
  // WebGL setup
  const gl = window.document.getElementById('c').getContext("webgl");
  console.log(gl);

  gl.clearColor(0, 0, 0, 1);
  gl.enable(gl.DEPTH_TEST);

  // Shaders
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, `
  attribute vec4 pos;
  uniform mat4 mvp;
  void main() { gl_Position = mvp * pos; }
`);
  gl.compileShader(vs);

  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, `
  void main() { gl_FragColor = vec4(1, 1, 1, 1); }
`);
  gl.compileShader(fs);

  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  gl.useProgram(prog);

  // Cube vertices (8 points) and edges
  const vertices = new Float32Array([
    -1,-1,-1,1, 1,-1,-1,1, 1,1,-1,1, -1,1,-1,1, // Front
    -1,-1,1,1,  1,-1,1,1,  1,1,1,1,   -1,1,1,1    // Back
  ]);
  const indices = new Uint16Array([
    0,1, 1,2, 2,3, 3,0, // Front
    4,5, 5,6, 6,7, 7,4, // Back
    0,4, 1,5, 2,6, 3,7  // Sides
  ]);

  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  const posLoc = gl.getAttribLocation(prog, "pos");
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 4, gl.FLOAT, false, 0, 0);

  const mvpLoc = gl.getUniformLocation(prog, "mvp");

  // Matrix 4x4 functions (minimal)
  function createMat4() {
    return [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]];
  }

  function multiplyMat4(a, b) {
    const r = createMat4();
    for (let i = 0; i < 4; i++)
      for (let j = 0; j < 4; j++)
        r[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j] + a[i][3]*b[3][j];
    return r;
  }

  function perspectiveMat4(fov, aspect, near, far) {
    const f = 1/Math.tan(fov/2), nf = 1/(near-far);
    return [
      [f/aspect, 0, 0, 0],
      [0, f, 0, 0],
      [0, 0, (far+near)*nf, 2*far*near*nf],
      [0, 0, -1, 0]
    ];
  }

  function translateMat4(tx, ty, tz) {
    return [[1,0,0,tx], [0,1,0,ty], [0,0,1,tz], [0,0,0,1]];
  }

  function rotateYMat4(angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return [[c,0,s,0], [0,1,0,0], [-s,0,c,0], [0,0,0,1]];
  }

  // Animation
  let angle = 0;
  function render() {
    angle += 0.01;
    const proj = perspectiveMat4(Math.PI/3, 1, 0.1, 100);
    const view = translateMat4(0, 0, -5); // Camera at z = -5
    const model = rotateYMat4(angle);
    let mvp = multiplyMat4(proj, view);
    mvp = multiplyMat4(mvp, model);

    // Flatten matrix for WebGL (row-major to column-major)
    const mvpFlat = new Float32Array([
      mvp[0][0], mvp[1][0], mvp[2][0], mvp[3][0],
      mvp[0][1], mvp[1][1], mvp[2][1], mvp[3][1],
      mvp[0][2], mvp[1][2], mvp[2][2], mvp[3][2],
      mvp[0][3], mvp[1][3], mvp[2][3], mvp[3][3]
    ]);

    gl.uniformMatrix4fv(mvpLoc, false, mvpFlat);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 0);
    requestAnimationFrame(render);
  }
  render();
</script>
