<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation d'Origami 3D</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .canvas-container {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        canvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: #000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            min-width: 120px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: linear-gradient(145deg, #764ba2, #667eea);
        }

        .btn:active {
            transform: translateY(0);
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
        }

        input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }

        .status {
            font-size: 16px;
            font-weight: bold;
            color: #4ecdc4;
            margin: 10px 0;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üé® Animation d'Origami 3D</h1>

    <div class="canvas-container">
        <canvas id="origamiCanvas" width="800" height="600"></canvas>
    </div>

    <div class="controls">
        <button class="btn" onclick="animateSplit()">üîÑ Split</button>
        <button class="btn" onclick="animateRotate()">‚Üª Rotate</button>
        <button class="btn" onclick="animateAdjust()">‚öñÔ∏è Adjust</button>
        <button class="btn" onclick="animateSequence()">üé¨ S√©quence</button>
        <button class="btn" onclick="resetOrigami()">üîÑ Reset</button>
    </div>

    <div class="animation-controls">
        <label>Vitesse:</label>
        <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1">
        <span id="speedValue">1x</span>
    </div>

    <div class="status" id="status">Pr√™t</div>

    <div class="info">
        <strong>Instructions:</strong> Cliquez sur les boutons pour voir les transformations de l'origami 3D.
        <br><strong>Split:</strong> Divise et s√©pare les sections
        <br><strong>Rotate:</strong> Rotation 3D autour de diff√©rents axes
        <br><strong>Adjust:</strong> Ajuste les proportions et la forme
        <br><strong>S√©quence:</strong> Combine toutes les animations
    </div>
</div>

<script>
    // Classe pour mod√©liser l'origami 3D
    class OrigamiModel {
        constructor() {
            this.points = this.initializePoints();
            this.faces = this.initializeFaces();
            this.center = { x: 0, y: 0, z: 0 };
            this.rotation = { x: 0.2, y: 0.3, z: 0 };
        }

        // Initialiser les points 3D pour un origami simple (grue stylis√©e)
        initializePoints() {
            return [
                // Corps principal
                { x: -100, y: -50, z: 0, id: 'body_0' },
                { x: 100, y: -50, z: 0, id: 'body_1' },
                { x: 100, y: 50, z: 0, id: 'body_2' },
                { x: -100, y: 50, z: 0, id: 'body_3' },

                // Ailes gauche
                { x: -150, y: -100, z: 20, id: 'wing_l_0' },
                { x: -50, y: -80, z: 15, id: 'wing_l_1' },
                { x: -80, y: 0, z: 10, id: 'wing_l_2' },
                { x: -150, y: 20, z: 25, id: 'wing_l_3' },

                // Ailes droite
                { x: 150, y: -100, z: 20, id: 'wing_r_0' },
                { x: 50, y: -80, z: 15, id: 'wing_r_1' },
                { x: 80, y: 0, z: 10, id: 'wing_r_2' },
                { x: 150, y: 20, z: 25, id: 'wing_r_3' },

                // T√™te
                { x: 0, y: -120, z: 30, id: 'head_0' },
                { x: -30, y: -90, z: 25, id: 'head_1' },
                { x: 30, y: -90, z: 25, id: 'head_2' },

                // Queue
                { x: 0, y: 120, z: 15, id: 'tail_0' },
                { x: -20, y: 80, z: 10, id: 'tail_1' },
                { x: 20, y: 80, z: 10, id: 'tail_2' }
            ];
        }

        // D√©finir les faces pour le rendu
        initializeFaces() {
            return [
                // Corps
                [0, 1, 2, 3],
                // Aile gauche
                [4, 5, 6, 7],
                // Aile droite
                [8, 9, 10, 11],
                // T√™te
                [12, 13, 14],
                // Queue
                [15, 16, 17]
            ];
        }

        // M√©thode split - divise et s√©pare les sections
        split(factor = 1.0, axis = 'x') {
            const newPoints = [];

            this.points.forEach(point => {
                const newPoint = { ...point };

                // S√©parer selon l'ID du point
                if (point.id.includes('wing_l')) {
                    newPoint.x -= 50 * factor;
                    newPoint.z += 20 * factor;
                } else if (point.id.includes('wing_r')) {
                    newPoint.x += 50 * factor;
                    newPoint.z += 20 * factor;
                } else if (point.id.includes('head')) {
                    newPoint.y -= 30 * factor;
                    newPoint.z += 15 * factor;
                } else if (point.id.includes('tail')) {
                    newPoint.y += 40 * factor;
                    newPoint.x *= (1 + 0.3 * factor);
                }

                newPoints.push(newPoint);
            });

            this.points = newPoints;
            return this;
        }

        // M√©thode rotate - rotation 3D autour de diff√©rents axes
        rotate(angleX = 0, angleY = 0, angleZ = 0) {
            this.rotation.x += angleX;
            this.rotation.y += angleY;
            this.rotation.z += angleZ;

            const newPoints = this.points.map(point => {
                let { x, y, z } = point;

                // Rotation autour de X
                if (angleX !== 0) {
                    const cosX = Math.cos(angleX);
                    const sinX = Math.sin(angleX);
                    const newY = y * cosX - z * sinX;
                    const newZ = y * sinX + z * cosX;
                    y = newY;
                    z = newZ;
                }

                // Rotation autour de Y
                if (angleY !== 0) {
                    const cosY = Math.cos(angleY);
                    const sinY = Math.sin(angleY);
                    const newX = x * cosY + z * sinY;
                    const newZ = -x * sinY + z * cosY;
                    x = newX;
                    z = newZ;
                }

                // Rotation autour de Z
                if (angleZ !== 0) {
                    const cosZ = Math.cos(angleZ);
                    const sinZ = Math.sin(angleZ);
                    const newX = x * cosZ - y * sinZ;
                    const newY = x * sinZ + y * cosZ;
                    x = newX;
                    y = newY;
                }

                return { ...point, x, y, z };
            });

            this.points = newPoints;
            return this;
        }

        // M√©thode adjust - ajuste les proportions et la forme
        adjust(scaleX = 1, scaleY = 1, scaleZ = 1, bend = 0) {
            const newPoints = this.points.map(point => {
                let { x, y, z } = point;

                // Mise √† l'√©chelle
                x *= scaleX;
                y *= scaleY;
                z *= scaleZ;

                // Effet de courbure
                if (bend !== 0) {
                    const bendFactor = bend * 0.001;
                    z += (x * x + y * y) * bendFactor;

                    // Ajustement sp√©cifique par section
                    if (point.id.includes('wing')) {
                        const wingBend = Math.sin(x * 0.01) * bend * 0.5;
                        z += wingBend;
                    }
                }

                return { ...point, x, y, z };
            });

            this.points = newPoints;
            return this;
        }

        // Obtenir une copie des points actuels
        getPoints() {
            return [...this.points];
        }

        // Projeter les points 3D en 2D pour le rendu
        project3D(point, centerX, centerY, distance = 500) {
            const z = point.z + distance;
            return {
                x: centerX + (point.x * distance) / z,
                y: centerY + (point.y * distance) / z,
                scale: distance / z
            };
        }
    }

    // Animation personnalis√©e bas√©e sur le polyfill
    class OrigamiAnimation {
        constructor(model, renderer, duration = 1000) {
            this.model = model;
            this.renderer = renderer;
            this.duration = duration;
            this.startTime = null;
            this.isRunning = false;
            this.animationId = null;
            this.startState = null;
            this.targetState = null;
            this.easingFunction = this.easeInOutCubic;
            this.onComplete = null;
        }

        // Fonction d'easing
        easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        }

        // D√©marrer une animation avec une m√©thode sp√©cifique
        animate(method, ...args) {
            if (this.isRunning) this.stop();

            this.startState = this.model.getPoints();

            // Appliquer la transformation pour obtenir l'√©tat final
            const tempModel = new OrigamiModel();
            tempModel.points = [...this.startState];
            tempModel[method](...args);
            this.targetState = tempModel.getPoints();

            this.isRunning = true;
            this.startTime = performance.now();
            this.tick();
        }

        // Boucle d'animation
        tick() {
            if (!this.isRunning) return;

            const now = performance.now();
            const elapsed = now - this.startTime;
            const progress = Math.min(elapsed / this.duration, 1);
            const easedProgress = this.easingFunction(progress);

            // Interpoler entre l'√©tat initial et final
            const interpolatedPoints = this.startState.map((startPoint, index) => {
                const targetPoint = this.targetState[index];
                return {
                    ...startPoint,
                    x: startPoint.x + (targetPoint.x - startPoint.x) * easedProgress,
                    y: startPoint.y + (targetPoint.y - startPoint.y) * easedProgress,
                    z: startPoint.z + (targetPoint.z - startPoint.z) * easedProgress
                };
            });

            this.model.points = interpolatedPoints;
            this.renderer.render();

            if (progress >= 1) {
                this.complete();
            } else {
                this.animationId = requestAnimationFrame(() => this.tick());
            }
        }

        // Terminer l'animation
        complete() {
            this.isRunning = false;
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }
            if (this.onComplete) this.onComplete();
        }

        // Arr√™ter l'animation
        stop() {
            this.isRunning = false;
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }
        }
    }

    // Renderer pour dessiner l'origami
    class OrigamiRenderer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.centerX = canvas.width / 2;
            this.centerY = canvas.height / 2;
            this.colors = [
                '#ff6b6b', '#4ecdc4', '#45b7d1',
                '#f9ca24', '#6c5ce7', '#a29bfe'
            ];
        }

        render() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Projeter tous les points
            const projectedPoints = origami.points.map(point =>
                origami.project3D(point, this.centerX, this.centerY)
            );

            // Dessiner les faces avec tri par profondeur
            const facesWithDepth = origami.faces.map((face, index) => {
                const avgZ = face.reduce((sum, pointIndex) =>
                    sum + origami.points[pointIndex].z, 0) / face.length;
                return { face, index, depth: avgZ };
            });

            // Trier par profondeur (les plus √©loign√©s d'abord)
            facesWithDepth.sort((a, b) => a.depth - b.depth);

            // Dessiner chaque face
            facesWithDepth.forEach(({ face, index }) => {
                this.ctx.beginPath();
                this.ctx.fillStyle = this.colors[index % this.colors.length] + '80';
                this.ctx.strokeStyle = this.colors[index % this.colors.length];
                this.ctx.lineWidth = 2;

                const firstPoint = projectedPoints[face[0]];
                this.ctx.moveTo(firstPoint.x, firstPoint.y);

                for (let i = 1; i < face.length; i++) {
                    const point = projectedPoints[face[i]];
                    this.ctx.lineTo(point.x, point.y);
                }

                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
            });

            // Dessiner les points pour le debug
            projectedPoints.forEach((point, index) => {
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, 3 * point.scale, 0, Math.PI * 2);
                this.ctx.fillStyle = '#fff';
                this.ctx.fill();
            });
        }
    }

    // Initialisation
    const canvas = document.getElementById('origamiCanvas');
    const origami = new OrigamiModel();
    const renderer = new OrigamiRenderer(canvas);
    const animation = new OrigamiAnimation(origami, renderer);

    let currentAnimation = null;
    const statusEl = document.getElementById('status');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');

    // Gestion de la vitesse
    speedSlider.addEventListener('input', (e) => {
        const speed = parseFloat(e.target.value);
        speedValue.textContent = speed + 'x';
        animation.duration = 1000 / speed;
    });

    // Fonction utilitaire pour l'√©tat
    function setStatus(message) {
        statusEl.textContent = message;
    }

    function animateSplit() {
        setStatus('Animation Split en cours...');
        animation.onComplete = () => setStatus('Split termin√©');
        animation.animate('split', Math.random() * 0.8 + 0.2);
    }

    function animateRotate() {
        setStatus('Animation Rotate en cours...');
        animation.onComplete = () => setStatus('Rotation termin√©e');
        const angleX = (Math.random() - 0.5) * Math.PI * 0.5;
        const angleY = (Math.random() - 0.5) * Math.PI * 0.5;
        const angleZ = (Math.random() - 0.5) * Math.PI * 0.3;
        animation.animate('rotate', angleX, angleY, angleZ);
    }

    function animateAdjust() {
        setStatus('Animation Adjust en cours...');
        animation.onComplete = () => setStatus('Ajustement termin√©');
        const scaleX = 0.7 + Math.random() * 0.6;
        const scaleY = 0.7 + Math.random() * 0.6;
        const scaleZ = 0.8 + Math.random() * 0.4;
        const bend = (Math.random() - 0.5) * 100;
        animation.animate('adjust', scaleX, scaleY, scaleZ, bend);
    }

    function animateSequence() {
        setStatus('S√©quence d\'animation en cours...');
        let step = 0;
        const steps = [
            () => animation.animate('split', 0.5),
            () => animation.animate('rotate', 0.3, 0.4, 0.1),
            () => animation.animate('adjust', 1.2, 0.8, 1.1, 50),
            () => animation.animate('rotate', -0.2, 0.2, -0.1)
        ];

        function nextStep() {
            if (step < steps.length) {
                animation.onComplete = () => {
                    step++;
                    setTimeout(nextStep, 300);
                };
                steps[step]();
            } else {
                setStatus('S√©quence termin√©e');
            }
        }

        nextStep();
    }

    function resetOrigami() {
        animation.stop();
        origami.points = origami.initializePoints();
        origami.rotation = { x: 0.2, y: 0.3, z: 0 };
        renderer.render();
        setStatus('Origami remis √† z√©ro');
    }

    // Rendu initial
    renderer.render();
    setStatus('Pr√™t - Cliquez sur un bouton pour commencer');

    // Animation de rotation continue l√©g√®re pour l'effet visuel
    function continuousRotation() {
        if (!animation.isRunning) {
            origami.rotate(0.005, 0.003, 0.001);
            renderer.render();
        }
        requestAnimationFrame(continuousRotation);
    }
    continuousRotation();
</script>
</body>
</html>
