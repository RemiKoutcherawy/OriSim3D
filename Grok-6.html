<!DOCTYPE html>
<style>canvas { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }</style>
<canvas id="c"></canvas>
<script>
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");
  let width, height, imgData, depthBuffer;

  function resize() {
    width = c.width = window.innerWidth;
    height = c.height = window.innerHeight;
    imgData = ctx.createImageData(width, height);
    depthBuffer = Array(height).fill().map(() => Array(width).fill(Infinity));
  }
  window.onresize = resize;
  resize();

  function putPixel(x, y, color, z) {
    x = Math.floor(x); y = Math.floor(y);
    if (x < 0 || x >= width || y < 0 || y >= height) return;
    if (z < depthBuffer[y][x]) {
      const i = (y * width + x) * 4;
      imgData.data[i] = color[0]; imgData.data[i + 1] = color[1]; imgData.data[i + 2] = color[2]; imgData.data[i + 3] = 255;
      depthBuffer[y][x] = z;
    }
  }

  function cross(v1, v2) {
    return [v1[1]*v2[2]-v1[2]*v1[1], v1[2]*v2[0]-v1[0]*v2[2], v1[0]*v2[1]-v1[1]*v2[0]];
  }

  function dot(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
  }

  function normalize(v) {
    const len = Math.sqrt(dot(v, v));
    return len ? [v[0]/len, v[1]/len, v[2]/len] : v;
  }

  function createMat4() {
    return [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]];
  }

  function multiplyMat4(a, b) {
    const r = createMat4();
    for (let i = 0; i < 4; i++)
      for (let j = 0; j < 4; j++)
        r[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j] + a[i][3]*b[3][j];
    return r;
  }

  function transformVec4(mat, vec) {
    const r = [0, 0, 0, 0];
    for (let i = 0; i < 4; i++)
      r[i] = mat[i][0]*vec[0] + mat[i][1]*vec[1] + mat[i][2]*vec[2] + mat[i][3]*vec[3];
    return r;
  }

  function perspectiveMat4(fov, aspect, near, far) {
    const f = 1/Math.tan(fov/2), nf = 1/(near-far);
    return [[f/aspect,0,0,0], [0,f,0,0], [0,0,(far+near)*nf,2*far*near*nf], [0,0,-1,0]];
  }

  function translateMat4(tx, ty, tz) {
    return [[1,0,0,tx], [0,1,0,ty], [0,0,1,tz], [0,0,0,1]];
  }

  function rotateYMat4(angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return [[c,0,s,0], [0,1,0,0], [-s,0,c,0], [0,0,0,1]];
  }

  const vertices = [
    [-1,-1,-1,1], [1,-1,-1,1], [1,1,-1,1], [-1,1,-1,1],
    [-1,-1,1,1],  [1,-1,1,1],  [1,1,1,1],  [-1,1,1,1]
  ];

  const triangles = [
    {v: [0,1,2], c: [255,0,0]}, {v: [0,2,3], c: [255,0,0]},
    {v: [5,4,7], c: [0,255,0]}, {v: [5,7,6], c: [0,255,0]},
    {v: [4,0,3], c: [0,0,255]}, {v: [4,3,7], c: [0,0,255]}, // Left (blue)
    {v: [1,5,6], c: [255,255,0]}, {v: [1,6,2], c: [255,255,0]},
    {v: [3,2,6], c: [0,255,255]}, {v: [3,6,7], c: [0,255,255]},
    {v: [4,5,1], c: [255,0,255]}, {v: [4,1,0], c: [255,0,255]}
  ];

  function fillTriangle(p0, p1, p2, z0, z1, z2, color, normal) {
    const minX = Math.max(0, Math.floor(Math.min(p0[0], p1[0], p2[0])));
    const maxX = Math.min(width-1, Math.ceil(Math.max(p0[0], p1[0], p2[0])));
    const minY = Math.max(0, Math.floor(Math.min(p0[1], p1[1], p2[1])));
    const maxY = Math.min(height-1, Math.ceil(Math.max(p0[1], p1[1], p2[1])));

    for (let y = minY; y <= maxY; y++) {
      for (let x = minX; x <= maxX; x++) {
        const w0 = ((p1[1]-p2[1])*(x-p2[0]) + (p2[0]-p1[0])*(y-p2[1])) /
                ((p1[1]-p2[1])*(p0[0]-p2[0]) + (p2[0]-p1[0])*(p0[1]-p2[1]));
        const w1 = ((p2[1]-p0[1])*(x-p2[0]) + (p0[0]-p2[0])*(y-p2[1])) /
                ((p2[1]-p0[1])*(p1[0]-p2[0]) + (p0[0]-p2[0])*(p1[1]-p2[1]));
        const w2 = 1 - w0 - w1;
        if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
          const z = w0 * z0 + w1 * z1 + w2 * z2;
          putPixel(x, y, color, z);
        }
      }
    }
  }

  const lightDir = normalize([1, 1, 1]);
  const ambient = 0.2;
  let angle = 0;
  function render() {
    angle += 0.01;
    for (let i = 0; i < imgData.data.length; i += 4) imgData.data[i + 3] = 0;
    for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) depthBuffer[y][x] = Infinity;

    const proj = perspectiveMat4(Math.PI/3, width/height, 0.1, 100);
    const view = translateMat4(0, 0, -5);
    const model = rotateYMat4(angle);
    let mvp = multiplyMat4(proj, view);
    mvp = multiplyMat4(mvp, model);

    const projected = vertices.map(v => {
      const tv = transformVec4(mvp, v);
      const w = tv[3];
      return [(tv[0]/w + 1) * width/2, (1 - tv[1]/w) * height/2, tv[2]/w];
    });

    triangles.forEach(t => {
      const v0 = vertices[t.v[0]], v1 = vertices[t.v[1]], v2 = vertices[t.v[2]];
      const e1 = [v1[0]-v0[0], v1[1]-v0[1], v1[2]-v0[2]];
      const e2 = [v2[0]-v0[0], v2[1]-v0[1], v2[2]-v0[2]];
      let normal = normalize(cross(e1, e2));
      let factor = Math.max(0, dot(normal, lightDir)) * (1 - ambient) + ambient;
      const color = [t.c[0]*factor, t.c[1]*factor, t.c[2]*factor].map(c => Math.min(255, Math.max(0, Math.floor(c))));
      const p0 = projected[t.v[0]], p1 = projected[t.v[1]], p2 = projected[t.v[2]];
      const z0 = projected[t.v[0]][2], z1 = projected[t.v[1]][2], z2 = projected[t.v[2]][2];
      fillTriangle(p0, p1, p2, z0, z1, z2, color, normal);
    });

    ctx.putImageData(imgData, 0, 0);
    requestAnimationFrame(render);
  }

  render();
</script>
