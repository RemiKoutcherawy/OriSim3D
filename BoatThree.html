<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Boat Three.js</title>
</head>
<body>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js"
        }
    }
</script>
<!-- Utilisation de three et OrbitControls via CDN -->
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js?module';
    import { Model } from './js/Model.js';
    import { Command } from './js/Command.js';

    // Scène
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xCCE4FF);

    // Caméra
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.set(0, 0, 600);
    camera.lookAt(0, 0, 0);

    // Rendu
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Lumières
    const ambient = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambient);
    // Lumière directionnelle principale venant de face
    const dir = new THREE.DirectionalLight(0xffffff, 2);
    dir.position.set(0, 0, 1);
    scene.add(dir);

    // Textures
    const frontTexture = new THREE.TextureLoader().load('textures/front.jpg');
    frontTexture.colorSpace = THREE.SRGBColorSpace;
    const backTexture = new THREE.TextureLoader().load('textures/back.jpg');
    backTexture.colorSpace = THREE.SRGBColorSpace;
    const TEX_W = 400, TEX_H = 400;

    // Origami
    const model = new Model().init();
    let geometry = createGeometry(model);
    const command = new Command(model, geometry);

    function createGeometry(model) {
        const geometry = new THREE.BufferGeometry();

        // Faces
        const vtx = []; // vertex
        const ftx = []; // front texture coords
        const fnr = []; // front normals coords
        const fin = []; // front indices
        let index = 0;

        for (let iFace = 0; iFace < model.faces.length; iFace++) {
            const f = model.faces[iFace];
            const pts = f.points;
            // Normal needed for Offset and used for lightning
            f.normal = faceNormal(pts);
            const n = f.normal;
            // Triangle FAN can be used only because of convex CCW face
            const c = pts[0]; // center
            let p = pts[1]; // previous
            let s; // current point
            for (let i = 2; i < pts.length; i++) {
                s = pts[i];
                vtx.push(c.x + f.offset * n[0]);
                vtx.push(c.y + f.offset * n[1]);
                vtx.push(c.z + f.offset * n[2]);
                fnr.push(n[0], n[1], n[2]);
                // textures
                ftx.push((200 + c.xf) / TEX_W);
                ftx.push((200 + c.yf) / TEX_H);
                // index
                fin.push(index++);

                vtx.push(p.x + f.offset * n[0]);
                vtx.push(p.y + f.offset * n[1]);
                vtx.push(p.z + f.offset * n[2]);
                fnr.push(n[0], n[1], n[2]);
                // textures
                ftx.push((200 + p.xf) / TEX_W);
                ftx.push((200 + p.yf) / TEX_H);
                // index
                fin.push(index++);

                vtx.push(s.x + f.offset * n[0]);
                vtx.push(s.y + f.offset * n[1]);
                vtx.push(s.z + f.offset * n[2]);
                fnr.push(n[0], n[1], n[2]);
                // textures
                ftx.push((200 + s.xf) / TEX_W);
                ftx.push((200 + s.yf) / TEX_H);
                // index
                fin.push(index++);
                // next triangle
                p = s;
            }

            function faceNormal(pts) {
                const n = [3];
                for (let i = 0; i < pts.length - 2; i++) {
                    // Take triangles until p2p1 x p1p3 > 0.1
                    const p1 = pts[i], p2 = pts[i + 1], p3 = pts[i + 2];
                    const u = [p2.x - p1.x, p2.y - p1.y, p2.z - p1.z];
                    const v = [p3.x - p1.x, p3.y - p1.y, p3.z - p1.z];
                    n[0] = u[1] * v[2] - u[2] * v[1];
                    n[1] = u[2] * v[0] - u[0] * v[2];
                    n[2] = u[0] * v[1] - u[1] * v[0];
                    if (Math.abs(n[0]) + Math.abs(n[1]) + Math.abs(n[2]) > 0.1) {
                        break;
                    }
                }
                return n;
            }
        }

        // Attributes
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vtx), 3));
        geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(fnr), 3));
        geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(ftx), 2));
        geometry.setIndex(fin);
        return geometry;
    }

    const frontMat = new THREE.MeshPhongMaterial({
        color: 0xFFFFFF,
        side: THREE.FrontSide,
        map: frontTexture,
        specular: 0x444444,
        shininess: 100,
    });
    const backMat = new THREE.MeshPhongMaterial({
        color: 0xFFFFFF,
        side: THREE.BackSide,
        map: backTexture,
        specular: 0x444444,
        shininess: 100,
    });
    const front = new THREE.Mesh(geometry, frontMat);
    const back = new THREE.Mesh(geometry, backMat);
    scene.add(front);
    scene.add(back);

    let edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000});
    const wireframe = new THREE.LineSegments(edges, lineMaterial);
    scene.add(wireframe);

    // Controls
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.update();
    orbit.saveState();
    orbit.addEventListener('change', animate);
    window.addEventListener('dblclick', () => { orbit.reset(); });

    // Update geometry when the model changed
    function updateGeometry() {
        const oldGeometry = geometry;
        geometry = createGeometry(model);
        front.geometry = geometry;
        back.geometry = geometry;
        geometry.computeBoundingSphere();
        geometry.computeBoundingBox();
        if (oldGeometry && oldGeometry !== geometry) {
            oldGeometry.dispose();
        }
        const oldEdges = edges;
        edges = new THREE.EdgesGeometry(geometry);
        wireframe.geometry = edges;
        if (oldEdges && oldEdges !== edges) {
            oldEdges.dispose();
        }
        geometry.attributes.uv.needsUpdate = true;
        geometry.attributes.normal.needsUpdate = true;
        geometry.attributes.position.needsUpdate = true;
        geometry.index.needsUpdate = true;
    }

    // Boucle de rendu
    function animate() {
        requestAnimationFrame(animate);
        const changed = command.anim();
        if (changed) {
            updateGeometry();
        }
        renderer.render(scene, camera);
    }

    animate();

    // Ajuster au redimensionnement
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Origami script injection
    const script = document.getElementById('origami.txt');
    command.command(script.textContent);
</script>

<!-- Cocotte script -->
<div id="origami.txt" hidden="hidden">
    define 210 300
    // Boat
    lines
    // Fold top on bottom
    across2d 1 2;
    offset -1 0
    t 200 r 6 -180 2 3;
    // t 200 fit;
    // Crease edges at 45°
    across3d 4 5
    bisector3d 7 9
    bisector3d 6 9

    // Fold corners
    offset -1 3 0
    t 200 rotate 13 -180 4
    t 200 rotate 17 180 5

    // Crease bottom and top
    by3d 9 12
    by3d 10 11

    // Fold back
    offset -2 5 6;
    t 200 rotate 24 180 3 8 2;
    // Crease on 2D
    bisector2d 3 24 bisector2d 23 16
    // Fold corners
    t 200 rotate 27 -180 3 rotate 29 180 2;

    // Fold front
    offset 2 8 9;
    t 200 rotate 25 180 0 1 7;
    // Crease on 2D
    bisector2d 25 12 bisector2d 1 21
    // Fold corners
    t 200 rotate 31 180 0
    t 200 rotate 33 -180 1

    // Crease top
    by3d 15 16

    // Open
    t 200 r 15 -180 4 5 8 14 21 25 26  r 9 180 1 2 11 12 16 18 19 22;
    // t 200 fit

    // Turn on left
    t 200 tz 45

    // Crease diagonal
    perpendicular3d 13 15

    t 200 ty 45

    // Rotate triangle in front
    t 400 r 53 180 11 12 1 2;
    // Rotate triangle in back
    t 400 r 53 -180 9 10 0 3;

    t 200 ty -45

    // t 200 fit

    // Turn on right
    t 200 tz -45

    // Close Fixme
    t 200 r 15 -180 4 5 14 8 21 25 26 32 33 27 28 30 29  r 9 -180 1 2 11 12 16 18 19 22 34 a 33 mop 33 30 29;

    // t 200 fit

    // Open rotate around 36
    t 1000 r 36 135 32 14 33 27 28 4 5 30 29  r 36 -135 31 13 34  a 9 12 0 1 2 3 mop 12 11 mop 9 10 mos 60 3 mos 25 0 mos 23 1 mos 64 2

    // t 200 fit

    // Show
    iao
    t 1000 z 0.5;
    t 1000 fit;
    iao
    t 1000 ty 360
</div>
</body>
</html>
