<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Origami - Three.js</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #CCE4FF; }
    #info { position: absolute; top: 10px; left: 10px; color: #CCE4FF; font-family: system-ui, Arial, sans-serif; background: rgba(255,255,255,0.5); padding: 8px 10px; border-radius: 6px; }
  </style>
  <!-- Import Three.js via CDN -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
<div id="info">Vue 3D d'un carré 200×200 — Glisser pour pivoter, molette pour zoomer, double‑clic pour réinitialiser, glisser d’un coin à l’autre pour couper</div>
<script type="module">
  import * as THREE from 'three';

  // Scène
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xCCE4FF);

  // Caméra
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
  camera.position.set(0, 0, 400);
  camera.lookAt(0, 0, 0);
  const initialCameraPos = camera.position.clone();

  // Rendu
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  // Lumières (facultatives car on utilise MeshBasicMaterial pour le carré)
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.4);
  dir.position.set(1, 2, 3);
  scene.add(dir);

  // Carré 200x200 (un simple plan)
  const size = 200; // exigences: 200 par 200
  const planeGeo = new THREE.PlaneGeometry(size, size);
  // Couleurs différentes avant/arrière sans ShaderMaterial: deux meshes avec FrontSide/BackSide
  const frontColor = new THREE.Color(0xA5C6FA); // light blue (front)
  const backColor = new THREE.Color(0xFFF36D);  // lemon yellow (back)
  const frontMat = new THREE.MeshBasicMaterial({ color: frontColor, side: THREE.FrontSide });
  const backMat  = new THREE.MeshBasicMaterial({ color: backColor,  side: THREE.BackSide  });
  const planeFront = new THREE.Mesh(planeGeo, frontMat);
  const planeBack  = new THREE.Mesh(planeGeo, backMat);
  planeFront.userData.tag = 'paper';
  planeBack.userData.tag  = 'paper';
  // Suivi des maillages de papier pour le raycasting
  let paperMeshes = [planeFront, planeBack];
  const plane = new THREE.Group();
  plane.add(planeFront);
  plane.add(planeBack);
  scene.add(plane);

  // Points (coins) du carré pour interaction hover
  const pointGeom = new THREE.SphereGeometry(4, 16, 16);
  const defaultPointColor = 0x87CEEB; // skyblue
  const hoverPointColor = 0x0000ff;   // blue
  const makePointMaterial = () => new THREE.MeshBasicMaterial({ color: defaultPointColor, depthTest: false });
  const cornerPositions = [
    new THREE.Vector3(-size/2, -size/2, 0),
    new THREE.Vector3( size/2, -size/2, 0),
    new THREE.Vector3( size/2,  size/2, 0),
    new THREE.Vector3(-size/2,  size/2, 0),
  ];
  const pointMeshes = cornerPositions.map(pos => {
    const m = new THREE.Mesh(pointGeom, makePointMaterial());
    m.position.copy(pos);
    m.renderOrder = 2; // draw above
    return m;
  });
  pointMeshes.forEach(m => plane.add(m)); // attach to plane so they follow its rotation

  let hoveredPoint = null;
  const raycaster = new THREE.Raycaster();
  const pointerNDC = new THREE.Vector2();
  function updatePointerNDC(e) {
      // NDC signifie "Normalized Device Coordinates
      const rect = renderer.domElement.getBoundingClientRect();
      pointerNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointerNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  }
  function setHovered(mesh) {
    if (hoveredPoint === mesh) return;
    if (hoveredPoint) {
      hoveredPoint.material.color.set(defaultPointColor);
      hoveredPoint.scale.set(1, 1, 1);
    }
    hoveredPoint = mesh || null;
    if (hoveredPoint) {
      hoveredPoint.material.color.set(hoverPointColor);
      hoveredPoint.scale.set(1.66, 1.66, 1.66); // approx 10/6 ratio
    }
    if (!isDragging) {
      renderer.domElement.style.cursor = hoveredPoint ? 'pointer' : 'grab';
    }
  }
  function detectHover() {
    raycaster.setFromCamera(pointerNDC, camera);
    const intersects = raycaster.intersectObjects(pointMeshes, true);
    setHovered(intersects.length ? intersects[0].object : null);
  }

  // Contour du carré pour bien voir les bords (groupe pour pouvoir reconstruire après une découpe)
  const edgesGroup = new THREE.Group();
  scene.add(edgesGroup);
  function rebuildEdges(geometries) {
    // Clear existing edges
    while (edgesGroup.children.length) edgesGroup.remove(edgesGroup.children[0]);
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
    geometries.forEach((g) => {
      const e = new THREE.EdgesGeometry(g);
      const l = new THREE.LineSegments(e, mat);
      edgesGroup.add(l);
    });
    // Synchronize rotation with plane
    edgesGroup.rotation.copy(plane.rotation);
  }
  // Initial edges for the full square
  rebuildEdges([planeGeo]);

  // Aide visuelle: axes
  const axes = new THREE.AxesHelper(120);
  scene.add(axes);

  // Interaction souris: drag pour pivoter, molette pour zoomer
  let isDragging = false;
  let prev = { x: 0, y: 0 };
  const dragFactor = 0.005; // sensibilité du drag

  // Découpe: on commence sur un point, on relâche sur un autre
  let cutStart = null; // Mesh du point de départ
  let hasCut = false;  // pour éviter multiples découpes (simple démo)
  // Prévisualisation: ligne rouge du premier point au curseur / second point
  let cutPreviewLine = null;

  // Animation de pliage
  let foldActive = false;
  let foldAxis = new THREE.Vector3();
  let foldHinge = null; // Group pivot au bout de la diagonale
  let foldStartTime = 0;
  let foldDuration = 1200; // ms
  let foldTarget = Math.PI; // 180°
  let foldApplied = 0; // angle déjà appliqué

  renderer.domElement.style.cursor = 'grab';

  renderer.domElement.addEventListener('pointerdown', (e) => {
    // Déterminer si on clique sur un point pour commencer une découpe
    updatePointerNDC(e);
    detectHover();
    if (hoveredPoint && !hasCut) {
      cutStart = hoveredPoint;
      renderer.domElement.setPointerCapture(e.pointerId);
      renderer.domElement.style.cursor = 'crosshair';
      // Créer une ligne de prévisualisation
      if (cutPreviewLine) { plane.remove(cutPreviewLine); cutPreviewLine.geometry.dispose(); cutPreviewLine.material.dispose(); cutPreviewLine = null; }
      const geom = new THREE.BufferGeometry();
      const p = cutStart.position;
      const positions = new Float32Array([p.x, p.y, p.z, p.x, p.y, p.z]);
      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2, depthTest: false });
      cutPreviewLine = new THREE.Line(geom, mat);
      cutPreviewLine.renderOrder = 3;
      plane.add(cutPreviewLine);
      // ne pas activer la rotation
      return;
    }
    // Sinon: rotation
    isDragging = true;
    prev.x = e.clientX;
    prev.y = e.clientY;
    renderer.domElement.setPointerCapture(e.pointerId);
    renderer.domElement.style.cursor = 'grabbing';
  });

  renderer.domElement.addEventListener('pointermove', (e) => {
    // Always update hover state
    updatePointerNDC(e);
    detectHover();
    if (cutStart) {
      // Mettre à jour la ligne de prévisualisation: vers le point survolé ou l'intersection sur le papier
      if (cutPreviewLine) {
        const posAttr = cutPreviewLine.geometry.getAttribute('position');
        let target;
        if (hoveredPoint && hoveredPoint !== cutStart) {
          target = hoveredPoint.position.clone();
        } else {
          raycaster.setFromCamera(pointerNDC, camera);
          const intersects = raycaster.intersectObjects(paperMeshes, true);
          if (intersects.length) {
            // convertir en coords locales du plane
            target = plane.worldToLocal(intersects[0].point.clone());
          } else {
            // fallback: projeter loin devant
            target = cutStart.position.clone();
          }
        }
        posAttr.setXYZ(0, cutStart.position.x, cutStart.position.y, cutStart.position.z);
        posAttr.setXYZ(1, target.x, target.y, target.z);
        posAttr.needsUpdate = true;
        cutPreviewLine.geometry.computeBoundingSphere();
      }
      return;
    }
    if (!isDragging) return;
    const dx = e.clientX - prev.x;
    const dy = e.clientY - prev.y;
    prev.x = e.clientX;
    prev.y = e.clientY;
    // Appliquer la rotation en fonction du déplacement
    plane.rotation.y += dx * dragFactor; // yaw
    plane.rotation.x += dy * dragFactor; // pitch
    // Garder le contour synchronisé
    edgesGroup.rotation.copy(plane.rotation);
  });

  function performCut(pStartMesh, pEndMesh) {
    // Déterminer les indices des points (coins) dans pointMeshes
    const iStart = pointMeshes.indexOf(pStartMesh);
    const iEnd = pointMeshes.indexOf(pEndMesh);
    if (iStart === -1 || iEnd === -1 || iStart === iEnd) return;
    // Autoriser seulement les diagonales pour une vraie découpe
    const diag1 = (iStart === 0 && iEnd === 2) || (iStart === 2 && iEnd === 0);
    const diag2 = (iStart === 1 && iEnd === 3) || (iStart === 3 && iEnd === 1);
    if (!diag1 && !diag2) {
      console.log('Découpe ignorée: choisissez deux coins opposés pour couper en deux triangles.');
      return;
    }
    // Construire deux triangles
    const idx = [0,1,2,3];
    const triIndices = diag1 ? [[0,1,2],[0,2,3]] : [[1,2,3],[1,3,0]];
    const verts = cornerPositions; // Vector3
    function makeTriGeom(a,b,c) {
      const g = new THREE.BufferGeometry();
      const pos = new Float32Array([
        verts[a].x, verts[a].y, 0,
        verts[b].x, verts[b].y, 0,
        verts[c].x, verts[c].y, 0,
      ]);
      g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      g.computeVertexNormals();
      return g;
    }
    const g1 = makeTriGeom(...triIndices[0]);
    const g2 = makeTriGeom(...triIndices[1]);

    // Remplacer uniquement les parties 'paper' du plan par 2 faces (chaque face = front + back)
    // et reconstruire la liste des meshes de papier pour le raycasting
    for (let i = plane.children.length - 1; i >= 0; i--) {
      const child = plane.children[i];
      if (child.userData && child.userData.tag === 'paper') {
        plane.remove(child);
      }
    }
    paperMeshes = [];
    function addFace(geom) {
      const front = new THREE.Mesh(geom, frontMat);
      const back  = new THREE.Mesh(geom, backMat);
      const grp = new THREE.Group();
      grp.userData.tag = 'paper';
      grp.add(front);
      grp.add(back);
      plane.add(grp);
      paperMeshes.push(front, back);
      return grp;
    }
    const face1 = addFace(g1);
    const face2 = addFace(g2);

    // Reconstruire les arêtes pour refléter les deux triangles (inclut la diagonale)
    rebuildEdges([g1, g2]);

    // Préparer l'animation de pliage autour de la diagonale
    startDiagonalFold(diag1 ? 0 : 1, diag1 ? 2 : 3, face2);

    hasCut = true;
  }

  function endDrag(e) {
    const isLeave = e && e.type === 'pointerleave';
    if (cutStart) {
      // Fin d'une tentative de découpe
      try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
      if (!isLeave && hoveredPoint && hoveredPoint !== cutStart) {
        performCut(cutStart, hoveredPoint);
      }
      // Retirer la ligne de prévisualisation
      if (cutPreviewLine) {
        plane.remove(cutPreviewLine);
        cutPreviewLine.geometry.dispose();
        cutPreviewLine.material.dispose();
        cutPreviewLine = null;
      }
      cutStart = null;
      // Mettre à jour le curseur selon le survol
      renderer.domElement.style.cursor = hoveredPoint ? 'pointer' : 'grab';
      return;
    }
    if (!isDragging) {
      if (isLeave) {
        // Clear hover when leaving canvas
        setHovered(null);
        renderer.domElement.style.cursor = 'grab';
      } else if (e) {
        // Update hover state on end events (e.g., pointerup without dragging)
        updatePointerNDC(e);
        detectHover();
      }
      return;
    }
    isDragging = false;
    try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
    if (isLeave) {
      setHovered(null);
      renderer.domElement.style.cursor = 'grab';
    } else {
      // After ending drag, recompute hover to set correct cursor if over a point
      if (e) { updatePointerNDC(e); detectHover(); }
      renderer.domElement.style.cursor = hoveredPoint ? 'pointer' : 'grab';
    }
  }

  renderer.domElement.addEventListener('pointerup', endDrag);
  renderer.domElement.addEventListener('pointerleave', endDrag);

  // Zoom basique avec la molette
  renderer.domElement.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY); // 1 = zoom out, -1 = zoom in
    const dir = camera.position.clone().normalize();
    let dist = camera.position.length();
    dist = THREE.MathUtils.clamp(dist + delta * 15, 60, 2000);
    camera.position.copy(dir.multiplyScalar(dist));
    camera.lookAt(0, 0, 0);
  }, { passive: false });

  // Double-clic pour réinitialiser rotation et zoom
  renderer.domElement.addEventListener('dblclick', () => {
    // Réinitialiser la rotation du carré (et du contour)
    plane.rotation.set(0, 0, 0);
    edgesGroup.rotation.copy(plane.rotation);
    // Réinitialiser la caméra (zoom et orientation)
    camera.position.copy(initialCameraPos);
    camera.lookAt(0, 0, 0);
    // Nettoyer une éventuelle ligne de prévisualisation
    if (cutPreviewLine) {
      plane.remove(cutPreviewLine);
      cutPreviewLine.geometry.dispose();
      cutPreviewLine.material.dispose();
      cutPreviewLine = null;
    }
    // Arrêter un éventuel drag en cours
    isDragging = false;
  });

  // Fonction utilitaire: attacher des arêtes blanches à un groupe de face (utilise la géométrie du premier mesh enfant)
  function attachEdgesToFace(faceGroup) {
    if (!faceGroup || !faceGroup.children || faceGroup.children.length === 0) return;
    const firstMesh = faceGroup.children.find(c => c.isMesh);
    if (!firstMesh) return;
    const e = new THREE.EdgesGeometry(firstMesh.geometry);
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
    const l = new THREE.LineSegments(e, mat);
    l.renderOrder = 2;
    faceGroup.add(l);
  }

  // Démarre l'animation de pliage autour de la diagonale [iA-iB]. foldingFace est le groupe de face à plier
  function startDiagonalFold(iA, iB, foldingFace) {
    // Masquer le groupe d'arêtes global et mettre des arêtes sur chaque face pour suivre le pli
    edgesGroup.visible = false;
    // Attacher des arêtes aux deux faces (celle qui plie et l'autre)
    attachEdgesToFace(foldingFace);
    const otherFace = plane.children.find(c => c.userData && c.userData.tag === 'paper' && c !== foldingFace);
    attachEdgesToFace(otherFace);

    // Construire un pivot (charnière) au point iA et aligner l'axe sur la diagonale
    const pA = cornerPositions[iA].clone();
    const pB = cornerPositions[iB].clone();
    foldAxis.copy(pB).sub(pA).normalize();
    foldHinge = new THREE.Group();
    foldHinge.position.copy(pA);
    plane.add(foldHinge);

    // Re-parent la face qui plie sous la charnière tout en conservant sa transformée monde
    foldHinge.attach(foldingFace);

    // Init animation
    foldActive = true;
    foldStartTime = performance.now();
    foldApplied = 0;
  }

  // Boucle de rendu (sans rotation continue)
  function animate() {
    requestAnimationFrame(animate);

    // Avancer l'animation de pliage si active
    if (foldActive && foldHinge) {
      const t = THREE.MathUtils.clamp((performance.now() - foldStartTime) / foldDuration, 0, 1);
      // easing cosinus (in-out)
      const eased = 0.5 - 0.5 * Math.cos(Math.PI * t);
      const target = foldTarget * eased;
      const delta = target - foldApplied;
      if (Math.abs(delta) > 1e-6) {
        foldHinge.rotateOnAxis(foldAxis, delta);
        foldApplied = target;
      }
      if (t >= 1) {
        foldActive = false;
      }
    }

    renderer.render(scene, camera);
  }
  animate();

  // Ajuster au redimensionnement
  window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
