<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Origami - Three.js</title>
    <style>
        html, body {margin: 0;padding: 0;height: 100%;overflow: hidden;}
        #info {position: absolute;top: 10px;left: 10px;color: #0080ffcc;font-family: system-ui, Arial, sans-serif;background: #ffffff80;padding: 8px 10px;border-radius: 6px;}
    </style>
</head>
<body>
<div id="info">Origami Glisser pour pivoter, molette pour zoomer, double‑clic pour réinitialiser</div>
<script type="importmap">
    {
        "imports": {
            "three": "./js/three.module.js"
        }
    }
</script>
<script type="module">
    import * as three from './js/three.module.js';
    import {OrbitControls} from './js/OrbitControls.js';

    // Scène
    const scene = new three.Scene();
    scene.background = new three.Color(0xCCE4FF);

    // Caméra
    const camera = new three.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 400);
    camera.lookAt(0, 0, 0);

    // Rendu
    const renderer = new three.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Lumières
    const ambient = new three.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    const dir = new three.DirectionalLight(0xffffff, 3);
    dir.position.set(0, 0, 1);
    scene.add(dir);

    // Carré 200x200
    const planeGeoFront = new three.PlaneGeometry(200, 200);
    const planeGeoBack = new three.PlaneGeometry(200, 200);
    // Inverser les normales de la face arrière
    planeGeoBack.scale(-1, 1, 1);

    const frontMat = new three.MeshPhongMaterial({
        color: 0x70ACF3,
        side: three.FrontSide,
        shininess: 30
    });
    const backMat = new three.MeshPhongMaterial({
        color: 0xFFF36D,
        side: three.FrontSide,
        shininess: 30
    });

    const planeFront = new three.Mesh(planeGeoFront, frontMat);
    const planeBack = new three.Mesh(planeGeoBack, backMat);
    const plane = new three.Group();
    plane.add(planeFront);
    plane.add(planeBack);
    scene.add(plane);
    // Positions relatives des deux faces
    planeFront.position.z = 0.1;  // Léger décalage pour éviter le z-fighting
    planeBack.position.z = 0;
    // Wireframe
    const wireMaterial = new three.MeshLambertMaterial({color: 0x000000, wireframe: true})
    const wireMesh = new three.Mesh(planeGeoFront, wireMaterial)
    scene.add(wireMesh)
    // Controls
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.update();
    orbit.saveState();
    orbit.addEventListener('change', animate);
    window.addEventListener('dblclick', () => {
        orbit.reset();
    });

    // Aide visuelle: axes
    const axes = new three.AxesHelper(20);
    scene.add(axes);

    // Boucle de rendu
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    animate();

    // Ajuster au redimensionnement
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
